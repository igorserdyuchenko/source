<?xml version="1.0"?>

<st-source>
  <time-stamp>From VisualWorks®, 7.4 of December 5, 2005 on October 22, 2025 at 2:00:00 pm</time-stamp>
  <!-- Package TodoCore* -->

  <component-property>
    <name>TodoCore</name>
    <type>package</type>
    <property>packageName</property>
    <value>'TodoCore'</value>
  </component-property>

  <!-- ====================================================== -->
  <!-- Class: Task -->
  <!-- ====================================================== -->

  <class>
    <name>Task</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>title done createdAt lastModifiedAt priority tags</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>Task</class-id>
    <body>
      Task represents a single todo item with title, completion status, priority, and tags.
    </body>
  </comment>

  <methods>
    <class-id>Task</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initialize">initialize
      super initialize.
      done := false.
      createdAt := Date today.
      lastModifiedAt := DateAndTime now.
      priority := #medium.
      tags := OrderedCollection new.
    </body>
  </methods>

  <methods>
    <class-id>Task</class-id>
    <category>accessing</category>

    <body package="TodoCore" selector="title">title
      ^title
    </body>

    <body package="TodoCore" selector="title:">title: aString
      title := aString.
      self markModified.
    </body>

    <body package="TodoCore" selector="done">done
      ^done
    </body>

    <body package="TodoCore" selector="done:">done: aBoolean
      done := aBoolean.
      self markModified.
    </body>

    <body package="TodoCore" selector="createdAt">createdAt
      ^createdAt
    </body>

    <body package="TodoCore" selector="createdAt:">createdAt: aDate
      createdAt := aDate
    </body>

    <body package="TodoCore" selector="lastModifiedAt">lastModifiedAt
      ^lastModifiedAt
    </body>

    <body package="TodoCore" selector="lastModifiedAt:">lastModifiedAt: aTimestamp
      lastModifiedAt := aTimestamp
    </body>

    <body package="TodoCore" selector="priority">priority
      ^priority
    </body>

    <body package="TodoCore" selector="priority:">priority: aSymbol
      priority := aSymbol.
      self markModified.
    </body>

    <body package="TodoCore" selector="tags">tags
      ^tags
    </body>

    <body package="TodoCore" selector="tags:">tags: aCollection
      tags := aCollection.
      self markModified.
    </body>
  </methods>

  <methods>
    <class-id>Task</class-id>
    <category>operations</category>

    <body package="TodoCore" selector="markModified">markModified
      lastModifiedAt := DateAndTime now.
    </body>

    <body package="TodoCore" selector="addTag:">addTag: aString
      (tags includes: aString) ifFalse: [
        tags add: aString.
        self markModified].
    </body>

    <body package="TodoCore" selector="removeTag:">removeTag: aString
      tags remove: aString ifAbsent: [].
      self markModified.
    </body>

    <body package="TodoCore" selector="hasTag:">hasTag: aString
      ^tags includes: aString
    </body>

    <body package="TodoCore" selector="isHighPriority">isHighPriority
      ^priority = #high
    </body>

    <body package="TodoCore" selector="isMediumPriority">isMediumPriority
      ^priority = #medium
    </body>

    <body package="TodoCore" selector="isLowPriority">isLowPriority
      ^priority = #low
    </body>
  </methods>

  <methods>
    <class-id>Task</class-id>
    <category>printing</category>

    <body package="TodoCore" selector="printString">printString
      ^String streamContents: [:s |
        s nextPutAll: '[';
        nextPutAll: (priority asString asUppercase);
        nextPutAll: '] ';
        nextPutAll: title;
        nextPutAll: (done ifTrue: [' [✓]'] ifFalse: [' [ ]']).
        tags isEmpty ifFalse: [
          s nextPutAll: ' {';
          nextPutAll: (tags joinSeparatedBy: ', ');
          nextPutAll: '}']]
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: TaskRepository -->
  <!-- ====================================================== -->

  <class>
    <name>TaskRepository</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>tasks</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>TaskRepository</class-id>
    <body>
      TaskRepository manages a collection of tasks with filtering and search capabilities.
    </body>
  </comment>

  <methods>
    <class-id>TaskRepository</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initialize">initialize
      super initialize.
      tasks := OrderedCollection new.
    </body>
  </methods>

  <methods>
    <class-id>TaskRepository</class-id>
    <category>operations</category>

    <body package="TodoCore" selector="addTask:">addTask: aTask
      tasks add: aTask.
    </body>

    <body package="TodoCore" selector="removeTask:">removeTask: aTask
      tasks remove: aTask ifAbsent: [].
    </body>

    <body package="TodoCore" selector="allTasks">allTasks
      ^tasks
    </body>

    <body package="TodoCore" selector="completedTasks">completedTasks
      ^tasks select: [:t | t done]
    </body>

    <body package="TodoCore" selector="pendingTasks">pendingTasks
      ^tasks reject: [:t | t done]
    </body>

    <body package="TodoCore" selector="size">size
      ^tasks size
    </body>
  </methods>

  <methods>
    <class-id>TaskRepository</class-id>
    <category>filtering</category>

    <body package="TodoCore" selector="tasksByPriority:">tasksByPriority: aPrioritySymbol
      ^tasks select: [:t | t priority = aPrioritySymbol]
    </body>

    <body package="TodoCore" selector="highPriorityTasks">highPriorityTasks
      ^self tasksByPriority: #high
    </body>

    <body package="TodoCore" selector="mediumPriorityTasks">mediumPriorityTasks
      ^self tasksByPriority: #medium
    </body>

    <body package="TodoCore" selector="lowPriorityTasks">lowPriorityTasks
      ^self tasksByPriority: #low
    </body>

    <body package="TodoCore" selector="tasksWithTag:">tasksWithTag: aString
      ^tasks select: [:t | t hasTag: aString]
    </body>

    <body package="TodoCore" selector="tasksModifiedAfter:">tasksModifiedAfter: aTimestamp
      ^tasks select: [:t | t lastModifiedAt > aTimestamp]
    </body>
  </methods>

  <methods>
    <class-id>TaskRepository</class-id>
    <category>searching</category>

    <body package="TodoCore" selector="searchByTitle:">searchByTitle: aString
      | searchLower |
      searchLower := aString asLowercase.
      ^tasks select: [:t | t title asLowercase includesSubstring: searchLower]
    </body>

    <body package="TodoCore" selector="findTaskMatching:">findTaskMatching: aBlock
      "Find tasks matching a condition block"
      ^tasks select: aBlock
    </body>
  </methods>

  <methods>
    <class-id>TaskRepository</class-id>
    <category>statistics</category>

    <body package="TodoCore" selector="completionRate">completionRate
      | total completed |
      total := tasks size.
      total = 0 ifTrue: [^0].
      completed := self completedTasks size.
      ^(completed / total * 100) asFloat
    </body>

    <body package="TodoCore" selector="taskCountByPriority">taskCountByPriority
      | counts |
      counts := Dictionary new.
      counts at: #high put: (self highPriorityTasks size).
      counts at: #medium put: (self mediumPriorityTasks size).
      counts at: #low put: (self lowPriorityTasks size).
      ^counts
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: TaskService -->
  <!-- ====================================================== -->

  <class>
    <name>TaskService</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>repository validator syncQueue</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>TaskService</class-id>
    <body>
      TaskService provides business logic for task operations with validation and sync tracking.
    </body>
  </comment>

  <methods>
    <class-id>TaskService</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initializeWithRepository:validator:syncQueue:">initializeWithRepository: aRepository validator: aValidator syncQueue: aSyncQueue
      repository := aRepository.
      validator := aValidator.
      syncQueue := aSyncQueue.
    </body>
  </methods>

  <methods>
    <class-id>TaskService</class-id>
    <category>api</category>

    <body package="TodoCore" selector="createTask:">createTask: aString
      ^self createTask: aString priority: #medium tags: #()
    </body>

    <body package="TodoCore" selector="createTask:priority:tags:">createTask: aString priority: aPrioritySymbol tags: aTags
      | task validationResult |
      task := Task new.
      task initialize.
      task title: aString.
      task priority: aPrioritySymbol.
      aTags do: [:tag | task addTag: tag].

      validationResult := validator validate: task.
      validationResult isValid ifFalse: [
        Transcript show: 'Validation failed: ', validationResult errorMessage; cr.
        ^nil].

      repository addTask: task.
      syncQueue recordChange: task operation: #create.
      ^task
    </body>

    <body package="TodoCore" selector="updateTask:title:">updateTask: aTask title: newTitle
      | validationResult |
      aTask title: newTitle.
      validationResult := validator validate: aTask.
      validationResult isValid ifTrue: [
        syncQueue recordChange: aTask operation: #update].
      ^validationResult
    </body>

    <body package="TodoCore" selector="updateTask:priority:">updateTask: aTask priority: newPriority
      aTask priority: newPriority.
      syncQueue recordChange: aTask operation: #update.
    </body>

    <body package="TodoCore" selector="completeTask:">completeTask: aTask
      aTask done: true.
      syncQueue recordChange: aTask operation: #update.
    </body>

    <body package="TodoCore" selector="deleteTask:">deleteTask: aTask
      repository removeTask: aTask.
      syncQueue recordChange: aTask operation: #delete.
    </body>

    <body package="TodoCore" selector="listTasks">listTasks
      ^repository allTasks
    </body>
  </methods>

  <methods>
    <class-id>TaskService</class-id>
    <category>bulk operations</category>

    <body package="TodoCore" selector="completeAllTasks">completeAllTasks
      repository allTasks do: [:task |
        self completeTask: task].
    </body>

    <body package="TodoCore" selector="deleteCompletedTasks">deleteCompletedTasks
      repository completedTasks copy do: [:task |
        self deleteTask: task].
    </body>

    <body package="TodoCore" selector="setPriorityForAll:priority:">setPriorityForAll: aTasks priority: aPriority
      aTasks do: [:task |
        self updateTask: task priority: aPriority].
    </body>
  </methods>

  <methods>
    <class-id>TaskService</class-id>
    <category>querying</category>

    <body package="TodoCore" selector="searchTasks:">searchTasks: aSearchString
      ^repository searchByTitle: aSearchString
    </body>

    <body package="TodoCore" selector="filterByPriority:">filterByPriority: aPrioritySymbol
      ^repository tasksByPriority: aPrioritySymbol
    </body>

    <body package="TodoCore" selector="filterByTag:">filterByTag: aTagString
      ^repository tasksWithTag: aTagString
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: SyncQueue -->
  <!-- ====================================================== -->

  <class>
    <name>SyncQueue</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>pendingChanges</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>SyncQueue</class-id>
    <body>
      SyncQueue tracks pending changes for synchronization with remote services.
    </body>
  </comment>

  <methods>
    <class-id>SyncQueue</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initialize">initialize
      super initialize.
      pendingChanges := OrderedCollection new.
    </body>
  </methods>

  <methods>
    <class-id>SyncQueue</class-id>
    <category>operations</category>

    <body package="TodoCore" selector="recordChange:operation:">recordChange: aTask operation: anOperationSymbol
      | change |
      change := Dictionary new.
      change at: #task put: aTask.
      change at: #operation put: anOperationSymbol.
      change at: #timestamp put: DateAndTime now.
      pendingChanges add: change.
    </body>

    <body package="TodoCore" selector="pendingChanges">pendingChanges
      ^pendingChanges
    </body>

    <body package="TodoCore" selector="clearPendingChanges">clearPendingChanges
      pendingChanges := OrderedCollection new.
    </body>

    <body package="TodoCore" selector="hasPendingChanges">hasPendingChanges
      ^pendingChanges notEmpty
    </body>

    <body package="TodoCore" selector="pendingChangeCount">pendingChangeCount
      ^pendingChanges size
    </body>

    <body package="TodoCore" selector="changesAfter:">changesAfter: aTimestamp
      ^pendingChanges select: [:change |
        (change at: #timestamp) > aTimestamp]
    </body>
  </methods>

  <methods>
    <class-id>SyncQueue</class-id>
    <category>reporting</category>

    <body package="TodoCore" selector="printPendingChanges">printPendingChanges
      Transcript show: '--- Pending Changes (', pendingChanges size printString, ') ---'; cr.
      pendingChanges do: [:change |
        Transcript show: '  ', (change at: #operation) asString asUppercase;
        show: ': ';
        show: ((change at: #task) title);
        cr].
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: TaskValidator -->
  <!-- ====================================================== -->

  <class>
    <name>TaskValidator</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars></inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>TaskValidator</class-id>
    <body>
      TaskValidator validates task data against business rules.
    </body>
  </comment>

  <methods>
    <class-id>TaskValidator</class-id>
    <category>validation</category>

    <body package="TodoCore" selector="validate:">validate: aTask
      | result |
      result := ValidationResult new.
      result initialize.

      "Check title"
      (aTask title isNil or: [aTask title isEmpty]) ifTrue: [
        result markInvalid: 'Task title cannot be empty'.
        ^result].

      aTask title size > 200 ifTrue: [
        result markInvalid: 'Task title too long (max 200 characters)'.
        ^result].

      "Check priority"
      (#(#low #medium #high) includes: aTask priority) ifFalse: [
        result markInvalid: 'Invalid priority (must be low, medium, or high)'.
        ^result].

      result markValid.
      ^result
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: ValidationResult -->
  <!-- ====================================================== -->

  <class>
    <name>ValidationResult</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>valid errorMessage</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>ValidationResult</class-id>
    <body>
      ValidationResult encapsulates the result of a validation operation.
    </body>
  </comment>

  <methods>
    <class-id>ValidationResult</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initialize">initialize
      super initialize.
      valid := false.
      errorMessage := ''.
    </body>
  </methods>

  <methods>
    <class-id>ValidationResult</class-id>
    <category>accessing</category>

    <body package="TodoCore" selector="isValid">isValid
      ^valid
    </body>

    <body package="TodoCore" selector="errorMessage">errorMessage
      ^errorMessage
    </body>

    <body package="TodoCore" selector="markValid">markValid
      valid := true.
      errorMessage := ''.
    </body>

    <body package="TodoCore" selector="markInvalid:">markInvalid: aString
      valid := false.
      errorMessage := aString.
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: TaskStatistics -->
  <!-- ====================================================== -->

  <class>
    <name>TaskStatistics</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>repository</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>TaskStatistics</class-id>
    <body>
      TaskStatistics calculates and reports metrics about tasks.
    </body>
  </comment>

  <methods>
    <class-id>TaskStatistics</class-id>
    <category>initialization</category>

    <body package="TodoCore" selector="initializeWithRepository:">initializeWithRepository: aRepository
      repository := aRepository.
    </body>
  </methods>

  <methods>
    <class-id>TaskStatistics</class-id>
    <category>metrics</category>

    <body package="TodoCore" selector="totalTasks">totalTasks
      ^repository size
    </body>

    <body package="TodoCore" selector="completedCount">completedCount
      ^repository completedTasks size
    </body>

    <body package="TodoCore" selector="pendingCount">pendingCount
      ^repository pendingTasks size
    </body>

    <body package="TodoCore" selector="completionRate">completionRate
      ^repository completionRate
    </body>

    <body package="TodoCore" selector="tasksByPriority">tasksByPriority
      ^repository taskCountByPriority
    </body>

    <body package="TodoCore" selector="highPriorityPending">highPriorityPending
      ^repository highPriorityTasks reject: [:t | t done]
    </body>
  </methods>

  <methods>
    <class-id>TaskStatistics</class-id>
    <category>reporting</category>

    <body package="TodoCore" selector="printReport">printReport
      | priorityCounts |
      Transcript show: '=== Task Statistics ==='; cr.
      Transcript show: 'Total tasks: ', self totalTasks printString; cr.
      Transcript show: 'Completed: ', self completedCount printString; cr.
      Transcript show: 'Pending: ', self pendingCount printString; cr.
      Transcript show: 'Completion rate: ', self completionRate printString, '%'; cr.

      priorityCounts := self tasksByPriority.
      Transcript show: 'By Priority:'; cr.
      Transcript show: '  High: ', (priorityCounts at: #high) printString; cr.
      Transcript show: '  Medium: ', (priorityCounts at: #medium) printString; cr.
      Transcript show: '  Low: ', (priorityCounts at: #low) printString; cr.

      Transcript show: 'High priority pending: ', self highPriorityPending size printString; cr.
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: TodoApp -->
  <!-- ====================================================== -->

  <class>
    <name>TodoApp</name>
    <environment>Smalltalk</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars></inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports>
      <import>TodoSync</import>
    </imports>
    <category>TodoCore</category>
    <attributes>
      <package>TodoCore</package>
    </attributes>
  </class>

  <comment>
    <class-id>TodoApp</class-id>
    <body>
      TodoApp demonstrates all features of the TodoCore package.
    </body>
  </comment>

  <methods>
    <class-id>TodoApp</class-id>
    <category>running</category>

    <body package="TodoCore" selector="start">start
      | repo service syncController validator syncQueue stats task1 task2 task3 task4 httpProxy wsProxy batchProxy |

      Transcript show: '╔════════════════════════════════════════╗'; cr.
      Transcript show: '║   Todo App - Enhanced Demo            ║'; cr.
      Transcript show: '╚════════════════════════════════════════╝'; cr; cr.

      "Initialize core components"
      repo := TaskRepository new.
      repo initialize.

      validator := TaskValidator new.

      syncQueue := SyncQueue new.
      syncQueue initialize.

      service := TaskService new.
      service initializeWithRepository: repo validator: validator syncQueue: syncQueue.

      stats := TaskStatistics new.
      stats initializeWithRepository: repo.

      "Initialize sync proxies"
      httpProxy := HttpSyncProxy new.
      httpProxy initialize.

      wsProxy := WebSocketSyncProxy new.
      wsProxy initialize.

      batchProxy := BatchSyncProxy new.
      batchProxy initialize.

      "Create tasks with different priorities and tags"
      Transcript show: '=== Creating Tasks ==='; cr.
      task1 := service createTask: 'Buy milk' priority: #high tags: #('shopping' 'urgent').
      task2 := service createTask: 'Write Smalltalk code' priority: #medium tags: #('work' 'coding').
      task3 := service createTask: 'Read a book' priority: #low tags: #('personal' 'leisure').
      task4 := service createTask: 'Exercise' priority: #medium tags: #('health' 'daily').

      "Complete and modify tasks"
      service completeTask: task1.
      service updateTask: task2 priority: #high.

      "Display all tasks"
      Transcript cr; show: '=== Task List ==='; cr.
      service listTasks do: [:t | Transcript show: t printString; cr].

      "Show statistics"
      Transcript cr.
      stats printReport.

      "Show pending sync changes"
      Transcript cr.
      syncQueue printPendingChanges.

      "Demonstrate HTTP sync with retry and auth"
      Transcript cr; show: '=== Syncing with HTTP Proxy ==='; cr.
      syncController := SyncController new.
      syncController initializeWith: repo provider: httpProxy syncQueue: syncQueue.
      syncController sync.

      "Create more tasks for batch demo"
      Transcript cr; show: '=== Adding More Tasks ==='; cr.
      service createTask: 'Call dentist' priority: #high tags: #('health').
      service createTask: 'Review pull request' priority: #medium tags: #('work').
      syncQueue printPendingChanges.

      "Demonstrate WebSocket real-time sync"
      Transcript cr; show: '=== Syncing with WebSocket Proxy ==='; cr.
      syncController switchProvider: wsProxy.
      syncController sync.

      "Create several more tasks for batch sync"
      Transcript cr; show: '=== Creating Batch of Tasks ==='; cr.
      service createTask: 'Task A' priority: #low tags: #('batch').
      service createTask: 'Task B' priority: #low tags: #('batch').
      service createTask: 'Task C' priority: #low tags: #('batch').
      syncQueue printPendingChanges.

      "Demonstrate batch sync"
      Transcript cr; show: '=== Syncing with Batch Proxy ==='; cr.
      syncController switchProvider: batchProxy.
      syncController sync.

      "Final statistics"
      Transcript cr; show: '=== Final Statistics ==='; cr.
      stats printReport.

      "Search and filter examples"
      Transcript cr; show: '=== Search &amp; Filter Demo ==='; cr.
      Transcript show: 'High priority tasks: '; cr.
      (service filterByPriority: #high) do: [:t | Transcript show: '  ', t printString; cr].

      Transcript show: 'Tasks with "work" tag: '; cr.
      (service filterByTag: 'work') do: [:t | Transcript show: '  ', t printString; cr].

      Transcript show: 'Search for "Task": '; cr.
      (service searchTasks: 'Task') do: [:t | Transcript show: '  ', t printString; cr].

      Transcript cr; show: '╔════════════════════════════════════════╗'; cr.
      Transcript show: '║   Application Demo Complete!          ║'; cr.
      Transcript show: '╚════════════════════════════════════════╝'; cr.
    </body>
  </methods>

</st-source>
