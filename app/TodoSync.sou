<?xml version="1.0"?>

<st-source>
  <time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on October 22, 2025 at 2:00:00 pm</time-stamp>
  <!-- Package TodoSync* -->

  <component-property>
    <name>TodoSync</name>
    <type>package</type>
    <property>packageName</property>
    <value>'TodoSync'</value>
  </component-property>

  <!-- ====================================================== -->
  <!-- Class: SyncProvider -->
  <!-- ====================================================== -->

  <class>
    <name>SyncProvider</name>
    <environment>TodoApp.Sync</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>implementation</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>SyncProvider</class-id>
    <body>
      SyncProvider is a proxy base class that forwards messages to the actual sync implementation.
    </body>
  </comment>

  <methods>
    <class-id>SyncProvider</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initializeWith:">initializeWith: anImplementation
      implementation := anImplementation
    </body>
  </methods>

  <methods>
    <class-id>SyncProvider</class-id>
    <category>proxying</category>

    <body package="TodoSync" selector="doesNotUnderstand:">doesNotUnderstand: aMessage
      ^implementation perform: aMessage selector withArguments: aMessage arguments
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: HttpSyncProxy -->
  <!-- ====================================================== -->

  <class>
    <name>HttpSyncProxy</name>
    <environment>TodoApp.Sync</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>authToken retryCount</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>HttpSyncProxy</class-id>
    <body>
      HttpSyncProxy provides HTTP-based synchronization with authentication and retry logic.
    </body>
  </comment>

  <methods>
    <class-id>HttpSyncProxy</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initialize">initialize
      super initialize.
      authToken := 'AUTH_TOKEN_12345'.
      retryCount := 3.
    </body>
  </methods>

  <methods>
    <class-id>HttpSyncProxy</class-id>
    <category>api</category>

    <body package="TodoSync" selector="syncTasks:">syncTasks: aCollection
      self syncTasksWithRetry: aCollection attempts: retryCount
    </body>

    <body package="TodoSync" selector="syncChanges:">syncChanges: aChangeCollection
      Transcript show: 'Syncing ', aChangeCollection size printString, ' changes via HTTP...'; cr.
      Transcript show: 'Auth: ', authToken; cr.
      aChangeCollection do: [:change |
        self syncChange: change].
      Transcript show: 'HTTP sync complete.'; cr.
    </body>
  </methods>

  <methods>
    <class-id>HttpSyncProxy</class-id>
    <category>private</category>

    <body package="TodoSync" selector="syncTasksWithRetry:attempts:">syncTasksWithRetry: aCollection attempts: attemptsRemaining
      | success |
      success := false.
      attemptsRemaining timesRepeat: [
        success ifFalse: [
          Transcript show: 'Attempting HTTP sync (', (retryCount - attemptsRemaining + 1) printString, '/', retryCount printString, ')...'; cr.
          success := self attemptSync: aCollection.
          success ifFalse: [
            Transcript show: 'Retry in 1 second...'; cr]]].
      success ifFalse: [
        Transcript show: 'HTTP sync failed after ', retryCount printString, ' attempts.'; cr].
    </body>

    <body package="TodoSync" selector="attemptSync:">attemptSync: aCollection
      Transcript show: 'Connecting to https://api.example.com/sync...'; cr.
      Transcript show: 'Auth: ', authToken; cr.
      aCollection do: [:t | Transcript show: 'â†’ Sent: ', t printString; cr].
      Transcript show: 'HTTP sync successful.'; cr.
      ^true
    </body>

    <body package="TodoSync" selector="syncChange:">syncChange: aChange
      | task operation |
      task := aChange at: #task.
      operation := aChange at: #operation.
      Transcript show: '  HTTP ', operation asString asUppercase, ': ', task title; cr.
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: SecureHttpSyncProxy -->
  <!-- ====================================================== -->

  <class>
    <name>SecureHttpSyncProxy</name>
    <environment>TodoApp.Sync</environment>
    <super>HttpSyncProxy</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>encryptionKey sslVersion certificatePath</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>SecureHttpSyncProxy</class-id>
    <body>
      SecureHttpSyncProxy extends HttpSyncProxy with enhanced security features.
      Demonstrates inheritance from a custom class (HttpSyncProxy).
    </body>
  </comment>

  <methods>
    <class-id>SecureHttpSyncProxy</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initialize">initialize
      super initialize.
      encryptionKey := 'AES256_KEY_PLACEHOLDER'.
      sslVersion := 'TLSv1.3'.
      certificatePath := '/etc/ssl/certs/app.pem'.
    </body>

    <body package="TodoSync" selector="initialize:">initialize: aCertPath
      "Initialize with custom certificate path"
      self initialize.
      certificatePath := aCertPath.
    </body>

    <body package="TodoSync" selector="initialize:ssl:">initialize: aCertPath ssl: aSslVersion
      "Initialize with custom certificate and SSL version"
      self initialize.
      certificatePath := aCertPath.
      sslVersion := aSslVersion.
    </body>
  </methods>

  <methods>
    <class-id>SecureHttpSyncProxy</class-id>
    <category>accessing</category>

    <body package="TodoSync" selector="encryptionKey">encryptionKey
      ^encryptionKey
    </body>

    <body package="TodoSync" selector="encryptionKey:">encryptionKey: aKey
      encryptionKey := aKey
    </body>

    <body package="TodoSync" selector="sslVersion">sslVersion
      ^sslVersion
    </body>

    <body package="TodoSync" selector="certificatePath">certificatePath
      ^certificatePath
    </body>
  </methods>

  <methods>
    <class-id>SecureHttpSyncProxy</class-id>
    <category>api</category>

    <body package="TodoSync" selector="syncTasks:">syncTasks: aCollection
      Transcript show: 'ðŸ”’ Secure HTTPS sync initiated...'; cr.
      Transcript show: 'SSL: ', sslVersion, ' | Cert: ', certificatePath; cr.
      self encryptData: aCollection.
      super syncTasks: aCollection.
      Transcript show: 'ðŸ”’ Secure sync complete.'; cr.
    </body>

    <body package="TodoSync" selector="syncChanges:">syncChanges: aChangeCollection
      Transcript show: 'ðŸ”’ Secure HTTPS change sync...'; cr.
      Transcript show: 'Encryption: Enabled (AES-256)'; cr.
      self encryptData: aChangeCollection.
      super syncChanges: aChangeCollection.
      Transcript show: 'ðŸ”’ Secure change sync complete.'; cr.
    </body>
  </methods>

  <methods>
    <class-id>SecureHttpSyncProxy</class-id>
    <category>private</category>

    <body package="TodoSync" selector="encryptData:">encryptData: aData
      Transcript show: '  Encrypting ', aData size printString, ' items with ', encryptionKey; cr.
    </body>

    <body package="TodoSync" selector="verifyCertificate">verifyCertificate
      Transcript show: '  Verifying SSL certificate: ', certificatePath; cr.
      ^true
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: WebSocketSyncProxy -->
  <!-- ====================================================== -->

  <class>
    <name>WebSocketSyncProxy</name>
    <environment>TodoApp.Sync</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>connected sessionId</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>WebSocketSyncProxy</class-id>
    <body>
      WebSocketSyncProxy provides real-time bidirectional synchronization via WebSocket.
    </body>
  </comment>

  <methods>
    <class-id>WebSocketSyncProxy</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initialize">initialize
      super initialize.
      connected := false.
      sessionId := nil.
    </body>
  </methods>

  <methods>
    <class-id>WebSocketSyncProxy</class-id>
    <category>connection</category>

    <body package="TodoSync" selector="connect">connect
      connected ifFalse: [
        Transcript show: 'Connecting to WebSocket: wss://sync.example.com...'; cr.
        sessionId := 'WS_SESSION_', DateAndTime now asString.
        connected := true.
        Transcript show: 'WebSocket connected. Session: ', sessionId; cr].
    </body>

    <body package="TodoSync" selector="disconnect">disconnect
      connected ifTrue: [
        Transcript show: 'Disconnecting WebSocket session...'; cr.
        connected := false.
        sessionId := nil.
        Transcript show: 'WebSocket disconnected.'; cr].
    </body>

    <body package="TodoSync" selector="isConnected">isConnected
      ^connected
    </body>
  </methods>

  <methods>
    <class-id>WebSocketSyncProxy</class-id>
    <category>api</category>

    <body package="TodoSync" selector="syncTasks:">syncTasks: aCollection
      self connect.
      Transcript show: 'Real-time sync via WebSocket...'; cr.
      aCollection do: [:t |
        Transcript show: 'â†’ Streaming: ', t printString; cr.
        self sendRealtimeUpdate: t].
      Transcript show: 'WebSocket sync complete.'; cr.
    </body>

    <body package="TodoSync" selector="syncChanges:">syncChanges: aChangeCollection
      self connect.
      Transcript show: 'Streaming ', aChangeCollection size printString, ' changes via WebSocket...'; cr.
      aChangeCollection do: [:change |
        self streamChange: change].
      Transcript show: 'WebSocket stream complete.'; cr.
    </body>
  </methods>

  <methods>
    <class-id>WebSocketSyncProxy</class-id>
    <category>private</category>

    <body package="TodoSync" selector="sendRealtimeUpdate:">sendRealtimeUpdate: aTask
      Transcript show: '  WS â†’ Server acknowledged: ', aTask title; cr.
    </body>

    <body package="TodoSync" selector="streamChange:">streamChange: aChange
      | task operation |
      task := aChange at: #task.
      operation := aChange at: #operation.
      Transcript show: '  WS ', operation asString asUppercase, ': ', task title, ' [ACK]'; cr.
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: BatchSyncProxy -->
  <!-- ====================================================== -->

  <class>
    <name>BatchSyncProxy</name>
    <environment>TodoApp.Sync</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>batchSize compressionEnabled</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports></imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>BatchSyncProxy</class-id>
    <body>
      BatchSyncProxy queues changes and uploads them in batches for bandwidth optimization.
    </body>
  </comment>

  <methods>
    <class-id>BatchSyncProxy</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initialize">initialize
      super initialize.
      batchSize := 10.
      compressionEnabled := true.
    </body>
  </methods>

  <methods>
    <class-id>BatchSyncProxy</class-id>
    <category>api</category>

    <body package="TodoSync" selector="syncTasks:">syncTasks: aCollection
      | batches |
      Transcript show: 'Preparing batch sync (batch size: ', batchSize printString, ')...'; cr.
      batches := self createBatches: aCollection.
      Transcript show: 'Created ', batches size printString, ' batch(es).'; cr.
      batches do: [:batch | self uploadBatch: batch].
      Transcript show: 'Batch sync complete.'; cr.
    </body>

    <body package="TodoSync" selector="syncChanges:">syncChanges: aChangeCollection
      | batches |
      Transcript show: 'Batch syncing ', aChangeCollection size printString, ' changes...'; cr.
      compressionEnabled ifTrue: [
        Transcript show: 'Compression: enabled'; cr].
      batches := self createChangeBatches: aChangeCollection.
      Transcript show: 'Uploading ', batches size printString, ' batch(es)...'; cr.
      batches doWithIndex: [:batch :index |
        self uploadChangeBatch: batch index: index total: batches size].
      Transcript show: 'All batches uploaded successfully.'; cr.
    </body>
  </methods>

  <methods>
    <class-id>BatchSyncProxy</class-id>
    <category>private</category>

    <body package="TodoSync" selector="createBatches:">createBatches: aCollection
      | batches currentBatch |
      batches := OrderedCollection new.
      currentBatch := OrderedCollection new.
      aCollection do: [:item |
        currentBatch add: item.
        currentBatch size = batchSize ifTrue: [
          batches add: currentBatch.
          currentBatch := OrderedCollection new]].
      currentBatch notEmpty ifTrue: [batches add: currentBatch].
      ^batches
    </body>

    <body package="TodoSync" selector="uploadBatch:">uploadBatch: aBatch
      Transcript show: 'â†’ Uploading batch of ', aBatch size printString, ' tasks...'; cr.
      aBatch do: [:t | Transcript show: '  â€¢ ', t printString; cr].
      Transcript show: '  Batch uploaded.'; cr.
    </body>

    <body package="TodoSync" selector="createChangeBatches:">createChangeBatches: aChangeCollection
      ^self createBatches: aChangeCollection
    </body>

    <body package="TodoSync" selector="uploadChangeBatch:index:total:">uploadChangeBatch: aBatch index: index total: total
      Transcript show: 'â†’ Batch ', index printString, '/', total printString, ' (', aBatch size printString, ' changes)'; cr.
      aBatch do: [:change |
        | task operation |
        task := change at: #task.
        operation := change at: #operation.
        Transcript show: '  â€¢ ', operation asString asUppercase, ': ', task title; cr].
      Transcript show: '  Batch ', index printString, ' uploaded.'; cr.
    </body>
  </methods>

  <!-- ====================================================== -->
  <!-- Class: SyncController -->
  <!-- ====================================================== -->

  <class>
    <name>SyncController</name>
    <environment>TodoApp.Sync</environment>
    <super>Core.Object</super>
    <private>false</private>
    <indexed-type>none</indexed-type>
    <inst-vars>repository provider syncQueue</inst-vars>
    <class-inst-vars></class-inst-vars>
    <imports>
      <import>TodoCore</import>
    </imports>
    <category>TodoSync</category>
    <attributes>
      <package>TodoSync</package>
    </attributes>
  </class>

  <comment>
    <class-id>SyncController</class-id>
    <body>
      SyncController orchestrates synchronization using different proxy strategies.
    </body>
  </comment>

  <methods>
    <class-id>SyncController</class-id>
    <category>initialization</category>

    <body package="TodoSync" selector="initializeWith:provider:">initializeWith: aRepo provider: aProvider
      repository := aRepo.
      provider := aProvider.
      syncQueue := nil.
    </body>

    <body package="TodoSync" selector="initializeWith:provider:syncQueue:">initializeWith: aRepo provider: aProvider syncQueue: aSyncQueue
      repository := aRepo.
      provider := aProvider.
      syncQueue := aSyncQueue.
    </body>
  </methods>

  <methods>
    <class-id>SyncController</class-id>
    <category>operations</category>

    <body package="TodoSync" selector="sync">sync
      syncQueue isNil
        ifTrue: [self syncAllTasks]
        ifFalse: [self syncPendingChanges]
    </body>

    <body package="TodoSync" selector="syncAllTasks">syncAllTasks
      | tasks |
      tasks := repository allTasks.
      tasks isEmpty
        ifTrue: [Transcript show: 'No tasks to sync.'; cr]
        ifFalse: [
          Transcript show: 'Starting full sync...'; cr.
          provider syncTasks: tasks.
          Transcript show: 'Sync done.'; cr]
    </body>

    <body package="TodoSync" selector="syncPendingChanges">syncPendingChanges
      syncQueue hasPendingChanges
        ifTrue: [
          Transcript show: 'Syncing ', syncQueue pendingChangeCount printString, ' pending changes...'; cr.
          provider syncChanges: syncQueue pendingChanges.
          syncQueue clearPendingChanges.
          Transcript show: 'Changes synced and queue cleared.'; cr]
        ifFalse: [
          Transcript show: 'No pending changes to sync.'; cr]
    </body>
  </methods>

  <methods>
    <class-id>SyncController</class-id>
    <category>configuration</category>

    <body package="TodoSync" selector="switchProvider:">switchProvider: aNewProvider
      provider := aNewProvider.
      Transcript show: 'Switched sync provider.'; cr.
    </body>

    <body package="TodoSync" selector="currentProvider">currentProvider
      ^provider
    </body>
  </methods>

</st-source>
